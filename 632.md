Boxy Ebony Rattlesnake

High

# Application of the Current Borrowing Index of lToken Twice

### Summary
In the `getHypotheticalAccountLiquidityCollateral` function, the returned value for borrowed amounts is in USD, already adjusted for the current borrow index. However, in several places within the `CoreRouter`, the current borrow index of lToken applied again. This discrepancy, particularly in the liquidation logic, can lead to users being liquidated when they should not be.

### Root Cause
The root cause is that the liquidation logic applies the current borrowing index of lToken twice, resulting in an inflated borrow amount being used in the liquidation.

### Internal pre-conditions
N/A

### External pre-conditions
N/A

### Attack Path
N/A

### PoC
https://github.com/sherlock-audit/2025-05-lend-audit-contest/blob/main/Lend-V2/src/LayerZero/LendStorage.sol#L509-L515
```solidity
    function borrowWithInterestSame(address borrower, address _lToken) public view returns (uint256) {
        uint256 borrowIndex = borrowBalance[borrower][_lToken].borrowIndex;
        uint256 borrowBalanceSameChain = borrowIndex != 0
            ? (borrowBalance[borrower][_lToken].amount * uint256(LTokenInterface(_lToken).borrowIndex())) / borrowIndex
            : 0;
        return borrowBalanceSameChain;
    }
```
As observed, the lToken.borrowIndex has already been applied to the borrowBalanceSameChain without updating the borrowBalance.borrowIndex.

https://github.com/sherlock-audit/2025-05-lend-audit-contest/blob/main/Lend-V2/src/LayerZero/LendStorage.sol#L425-L428
```solidity
    function getHypotheticalAccountLiquidityCollateral(
        address account,
        LToken lTokenModify,
        uint256 redeemTokens,
        uint256 borrowAmount
    ) public view returns (uint256, uint256) {
        ...
        // Second loop: Calculate borrow value from borrowed assets
        for (uint256 i = 0; i < borrowedAssets.length;) {
            LToken asset = LToken(borrowedAssets[i]);

            // Get borrow balance for this asset
425:        uint256 totalBorrow = borrowWithInterestSame(account, address(asset));

            // Add cross-chain borrows if any
428:        totalBorrow += borrowWithInterest(account, address(asset));

            // Get price for borrowed asset
            vars.oraclePriceMantissa = UniswapAnchoredViewInterface(priceOracle).getUnderlyingPrice(asset);
            vars.oraclePrice = Exp({mantissa: vars.oraclePriceMantissa});

            // Add to borrow sum
            vars.sumBorrowPlusEffects =
                mul_ScalarTruncateAddUInt(vars.oraclePrice, totalBorrow, vars.sumBorrowPlusEffects);

            unchecked {
                ++i;
            }
        }
        ...
```
https://github.com/sherlock-audit/2025-05-lend-audit-contest/blob/main/Lend-V2/src/LayerZero/CoreRouter.sol#L241
```solidity
    function liquidateBorrow(address borrower, uint256 repayAmount, address lTokenCollateral, address borrowedAsset)
        external
    {
        // The lToken of the borrowed asset
        address borrowedlToken = lendStorage.underlyingTolToken(borrowedAsset);

        LTokenInterface(borrowedlToken).accrueInterest();

        (uint256 borrowed, uint256 collateral) =
            lendStorage.getHypotheticalAccountLiquidityCollateral(borrower, LToken(payable(borrowedlToken)), 0, 0);

241:    liquidateBorrowInternal(
            msg.sender, borrower, repayAmount, lTokenCollateral, payable(borrowedlToken), collateral, borrowed
        );
    }
```
https://github.com/sherlock-audit/2025-05-lend-audit-contest/blob/main/Lend-V2/src/LayerZero/CoreRouter.sol#L266
```solidity

    function liquidateBorrowInternal(
        ...
        uint256 borrowed
    ) internal {
        require(
266:        liquidateBorrowAllowedInternal(borrowedlToken, borrower, repayAmount, collateral, borrowed) == 0,
            "Borrow not allowed"
        );
        require(borrower != liquidator, "Liquidator cannot be borrower");
        require(repayAmount > 0, "Repay amount not zero");

        repayBorrowInternal(borrower, liquidator, repayAmount, borrowedlToken, true);

        // Liquidation logic for same chain
        liquidateSeizeUpdate(msg.sender, borrower, lTokenCollateral, borrowedlToken, repayAmount);
    }
```

https://github.com/sherlock-audit/2025-05-lend-audit-contest/blob/main/Lend-V2/src/LayerZero/CoreRouter.sol#L347
```solidity
    function liquidateBorrowAllowedInternal(
        address payable lTokenBorrowed,
        address borrower,
        uint256 repayAmount,
        uint256 collateral,
        uint256 borrowed
    ) internal view returns (uint256) {
        // Determine borrowIndex and borrowAmount based on chain type
        LendStorage.BorrowMarketState memory borrowBalance = lendStorage.getBorrowBalance(borrower, lTokenBorrowed);

        // Allow accounts to be liquidated if the market is deprecated
        if (LendtrollerInterfaceV2(lendtroller).isDeprecated(LToken(lTokenBorrowed))) {
            require(borrowBalance.amount >= repayAmount, "Repay > total borrow");
        } else {
            // The borrower must have shortfall in order to be liquidatable
            uint256 borrowedAmount;

            // For same-chain liquidations, calculate borrowed amount using the borrowBalance's index
347:        borrowedAmount =
                (borrowed * uint256(LTokenInterface(lTokenBorrowed).borrowIndex())) / borrowBalance.borrowIndex;

            require(borrowedAmount > collateral, "Insufficient shortfall");

            /* The liquidator may not repay more than what is allowed by the closeFactor */
            uint256 maxClose = mul_ScalarTruncate(
                Exp({mantissa: LendtrollerInterfaceV2(lendtroller).closeFactorMantissa()}), borrowBalance.amount
            );

            require(repayAmount <= maxClose, "Too much repay");
        }

        return 0;
    }
```
In line 347, the `lToken.borrowIndex / borrowBalance.borrowIndex` is applied again, leading to inflation of borrowed amount.
In fact, this `borrowedAmount` is USD value of totalBorrow, which calculated in the `getHypotheticalAccountLiquidityCollateral` rather than lToken Amount.

### Impact
This resulting users being liquidated when they should not be.

### Mitigation
Ensure that the current borrow index of the lToken is applied to the borrowedAmount only once.