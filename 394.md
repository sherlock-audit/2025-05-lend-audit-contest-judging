Big Sable Whale

High

# DOS of _handleLiquidationSuccess function due to using payload.destlToken as input in repayCrossChainBorrowInternal function

### Summary







### Summary

when a borrower cross borrows tokens of chainB using borrowCrossChain function in chain A.Then a liquidator can call liquidateCrossChain function in chainB.which will do sufficient checks to send a msg to chain A via layerZero,
https://github.com/sherlock-audit/2025-05-lend-audit-contest/blob/713372a1ccd8090ead836ca6b1acf92e97de4679/Lend-V2/src/LayerZero/CrossChainRouter.sol#L172-L192
```solidity
    function liquidateCrossChain(
        address borrower,
        uint256 repayAmount,
        uint32 srcEid,
        address lTokenToSeize,
        address borrowedAsset
    ) external {
        LendStorage.LiquidationParams memory params = LendStorage.LiquidationParams({
            borrower: borrower,
            repayAmount: repayAmount,
            srcEid: srcEid,
            lTokenToSeize: lTokenToSeize, // Collateral lToken from the user's position to seize
            borrowedAsset: borrowedAsset,
            storedBorrowIndex: 0,
            borrowPrinciple: 0,
            borrowedlToken: address(0)
        });


        _validateAndPrepareLiquidation(params);
        _executeLiquidation(params);
    }
```
here lTokenToSeize is address of Ltoken in chainB corresponding to collateral Ltoken in chainA.
https://github.com/sherlock-audit/2025-05-lend-audit-contest/blob/713372a1ccd8090ead836ca6b1acf92e97de4679/Lend-V2/src/LayerZero/CrossChainRouter.sol#L264-L285
```solidity
    function _executeLiquidationCore(LendStorage.LiquidationParams memory params) private {
        // Calculate seize tokens
        address borrowedlToken = lendStorage.underlyingTolToken(params.borrowedAsset);


        (uint256 amountSeizeError, uint256 seizeTokens) = LendtrollerInterfaceV2(lendtroller)
            .liquidateCalculateSeizeTokens(borrowedlToken, params.lTokenToSeize, params.repayAmount);


        require(amountSeizeError == 0, "Seize calculation failed");


        // Send message to Chain A to execute the seize
        _send(
            params.srcEid,
            seizeTokens,
            params.storedBorrowIndex,
            0,
            params.borrower,
            lendStorage.crossChainLTokenMap(params.lTokenToSeize, params.srcEid), // Convert to Chain A version before sending
            msg.sender,
            params.borrowedAsset,
            ContractType.CrossChainLiquidationExecute
        );
    }
```
here if we observe payload.destltoken = collateral Ltoken in chain A.
and layerZero calls _lzreceive function of CrossChainRoute in  chainA, 
https://github.com/sherlock-audit/2025-05-lend-audit-contest/blob/713372a1ccd8090ead836ca6b1acf92e97de4679/Lend-V2/src/LayerZero/CrossChainRouter.sol#L772-L776
```solidity
        } else if (cType == ContractType.CrossChainLiquidationExecute) {
            if (_checkLiquidationValid(payload)) {
                _handleLiquidationExecute(payload, srcEid);
            } else {
                _sendLiquidationFailure(payload, srcEid);
```
this will check if this liquidation call is valid, using _checkLiquidationValid function.And if it is valid then _handleLiquidationExecute function will execute, 
https://github.com/sherlock-audit/2025-05-lend-audit-contest/blob/713372a1ccd8090ead836ca6b1acf92e97de4679/Lend-V2/src/LayerZero/CrossChainRouter.sol#L312-L366
```solidity
    function _handleLiquidationExecute(LZPayload memory payload, uint32 srcEid) private {
        // Execute the seize of collateral
        uint256 protocolSeizeShare = mul_(payload.amount, Exp({mantissa: lendStorage.PROTOCOL_SEIZE_SHARE_MANTISSA()}));


        require(protocolSeizeShare < payload.amount, "Invalid protocol share");


        uint256 liquidatorShare = payload.amount - protocolSeizeShare;


        // Update protocol rewards
        lendStorage.updateProtocolReward(
            payload.destlToken, lendStorage.protocolReward(payload.destlToken) + protocolSeizeShare
        );


        // Distribute LEND rewards
        lendStorage.distributeSupplierLend(payload.destlToken, payload.sender); // borrower
        lendStorage.distributeSupplierLend(payload.destlToken, payload.liquidator); // liquidator


        // Update total investment for borrower
        lendStorage.updateTotalInvestment(
            payload.sender,
            payload.destlToken,
            lendStorage.totalInvestment(payload.sender, payload.destlToken) - payload.amount
        );


        // Update total investment for liquidator
        lendStorage.updateTotalInvestment(
            payload.liquidator,
            payload.destlToken,
            lendStorage.totalInvestment(payload.liquidator, payload.destlToken) + liquidatorShare
        );


        // Clear user supplied asset if total investment is 0
        if (lendStorage.totalInvestment(payload.sender, payload.destlToken) == 0) {
            lendStorage.removeUserSuppliedAsset(payload.sender, payload.destlToken);
        }


        emit LiquidateBorrow(
            payload.liquidator, // liquidator
            payload.srcToken, // borrowed token
            payload.sender, // borrower
            payload.destlToken // collateral token
        );


        _send(
            srcEid,
            payload.amount,
            0,
            0,
            payload.sender,
            payload.destlToken,
            payload.liquidator,
            payload.srcToken,
            ContractType.LiquidationSuccess
        );
    }
```
here payload.destltoken = chainA collateral Ltoken.
now let's see how _handleLiquidationSuccess function in chain B handles it,
https://github.com/sherlock-audit/2025-05-lend-audit-contest/blob/713372a1ccd8090ead836ca6b1acf92e97de4679/Lend-V2/src/LayerZero/CrossChainRouter.sol#L443-L471
```solidity
    function _handleLiquidationSuccess(LZPayload memory payload) private {
        // Find the borrow position on Chain B to get the correct srcEid
        address underlying = lendStorage.lTokenToUnderlying(payload.destlToken);


        // Find the specific collateral record
        (bool found, uint256 index) = lendStorage.findCrossChainCollateral(
            payload.sender,
            underlying,
            currentEid, // srcEid is current chain
            0, // We don't know destEid yet, but we can match on other fields
            payload.destlToken,
            payload.srcToken
        );


        require(found, "Borrow position not found");


        LendStorage.Borrow[] memory userCollaterals = lendStorage.getCrossChainCollaterals(payload.sender, underlying);
        uint32 srcEid = uint32(userCollaterals[index].srcEid);


        // Now that we know the borrow position and srcEid, we can repay the borrow using the escrowed tokens
        // repayCrossChainBorrowInternal will handle updating state and distributing rewards.
        repayCrossChainBorrowInternal(
            payload.sender, // The borrower
            payload.liquidator, // The liquidator (repayer)
            payload.amount, // Amount to repay
            payload.destlToken, // lToken representing the borrowed asset on this chain
            srcEid // The chain where the collateral (and borrow reference) is tracked
        );
    }
```
here we are sending (payload.destlToken = chain A collateral Ltoken ) instead of borrowed token in chain B.
let's see  repayCrossChainBorrowInternal function,
https://github.com/sherlock-audit/2025-05-lend-audit-contest/blob/713372a1ccd8090ead836ca6b1acf92e97de4679/Lend-V2/src/LayerZero/CrossChainRouter.sol#L368-L381
```solidity
    function repayCrossChainBorrowInternal(
        address borrower,
        address repayer,
        uint256 _amount,
        address _lToken,
        uint32 _srcEid
    ) internal {
        address _token = lendStorage.lTokenToUnderlying(_lToken);
        LTokenInterface(_lToken).accrueInterest();


        // Get borrow details and validate
        (uint256 borrowedAmount, uint256 index, LendStorage.Borrow memory borrowPosition) =
            _getBorrowDetails(borrower, _token, _lToken, _srcEid);


```
where it sends that payload.destltoken as _ltoken to _getBorrowDetails function, let's  see that function,
https://github.com/sherlock-audit/2025-05-lend-audit-contest/blob/713372a1ccd8090ead836ca6b1acf92e97de4679/Lend-V2/src/LayerZero/CrossChainRouter.sol#L397-L411
```solidity
    function _getBorrowDetails(address borrower, address _token, address _lToken, uint32 _srcEid)
        private
        view
        returns (uint256 borrowedAmount, uint256 index, LendStorage.Borrow memory borrowPosition)
    {
        LendStorage.Borrow[] memory userCrossChainCollaterals = lendStorage.getCrossChainCollaterals(borrower, _token);
        bool found;


        for (uint256 i = 0; i < userCrossChainCollaterals.length;) {
            if (userCrossChainCollaterals[i].srcEid == _srcEid) {
                borrowPosition = userCrossChainCollaterals[i];
                index = i;
                found = true;
                borrowedAmount = (borrowPosition.principle * uint256(LTokenInterface(_lToken).borrowIndex()))
                    / uint256(borrowPosition.borrowIndex);
```
here it calls LTokenInterface(_lToken).borrowIndex() to find current borrow index of borrowed token but here this call will revert as we are using (payload.destltoken = chain A collateral Ltoken) as _lToken.and this chain doesn't have payload.destltoken address so this call will revert.













### Root Cause

using payload.destlToken instead of borrow Ltoken of this chain in below lines of code,
https://github.com/sherlock-audit/2025-05-lend-audit-contest/blob/713372a1ccd8090ead836ca6b1acf92e97de4679/Lend-V2/src/LayerZero/CrossChainRouter.sol#L468
```solidity
            payload.destlToken, // lToken representing the borrowed asset on this chain
```


### Internal Pre-conditions

none 

### External Pre-conditions

none 

### Attack Path

liquidator calls liquidate cross chain function 


### Impact

DOS of _handleLiquidationSuccess function.
due to this liquidator gets collateral tokens in chain A but he doesn't pay repay tokens in chain B.



### PoC

_No response_

### Mitigation

use borrow Ltoken of this chain instead of  payload.destlToken in below lines of code,
https://github.com/sherlock-audit/2025-05-lend-audit-contest/blob/713372a1ccd8090ead836ca6b1acf92e97de4679/Lend-V2/src/LayerZero/CrossChainRouter.sol#L468
```solidity
            payload.destlToken, // lToken representing the borrowed asset on this chain
```
