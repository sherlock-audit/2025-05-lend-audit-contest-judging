Big Sable Whale

High

# DOS of _handleLiquidationSuccess function due to using 0 as input in lendStorage.findCrossChainCollateral function instead of using currentEid

### Summary


when a borrower cross borrows tokens of chainB using borrowCrossChain function in chain A.Then a liquidator can call liquidateCrossChain function in chainB.which will do sufficient checks to send a msg to chain A via layerZero,
https://github.com/sherlock-audit/2025-05-lend-audit-contest/blob/713372a1ccd8090ead836ca6b1acf92e97de4679/Lend-V2/src/LayerZero/CrossChainRouter.sol#L172-L192
```solidity
    function liquidateCrossChain(
        address borrower,
        uint256 repayAmount,
        uint32 srcEid,
        address lTokenToSeize,
        address borrowedAsset
    ) external {
        LendStorage.LiquidationParams memory params = LendStorage.LiquidationParams({
            borrower: borrower,
            repayAmount: repayAmount,
            srcEid: srcEid,
            lTokenToSeize: lTokenToSeize, // Collateral lToken from the user's position to seize
            borrowedAsset: borrowedAsset,
            storedBorrowIndex: 0,
            borrowPrinciple: 0,
            borrowedlToken: address(0)
        });


        _validateAndPrepareLiquidation(params);
        _executeLiquidation(params);
    }
```

https://github.com/sherlock-audit/2025-05-lend-audit-contest/blob/713372a1ccd8090ead836ca6b1acf92e97de4679/Lend-V2/src/LayerZero/CrossChainRouter.sol#L264-L285
```solidity
    function _executeLiquidationCore(LendStorage.LiquidationParams memory params) private {
        // Calculate seize tokens
        address borrowedlToken = lendStorage.underlyingTolToken(params.borrowedAsset);


        (uint256 amountSeizeError, uint256 seizeTokens) = LendtrollerInterfaceV2(lendtroller)
            .liquidateCalculateSeizeTokens(borrowedlToken, params.lTokenToSeize, params.repayAmount);


        require(amountSeizeError == 0, "Seize calculation failed");


        // Send message to Chain A to execute the seize
        _send(
            params.srcEid,
            seizeTokens,
            params.storedBorrowIndex,
            0,
            params.borrower,
            lendStorage.crossChainLTokenMap(params.lTokenToSeize, params.srcEid), // Convert to Chain A version before sending
            msg.sender,
            params.borrowedAsset,
            ContractType.CrossChainLiquidationExecute
        );
    }
```

andnow  layerZero calls _lzreceive function of CrossChainRoute in  chainA, 
https://github.com/sherlock-audit/2025-05-lend-audit-contest/blob/713372a1ccd8090ead836ca6b1acf92e97de4679/Lend-V2/src/LayerZero/CrossChainRouter.sol#L772-L776
```solidity
        } else if (cType == ContractType.CrossChainLiquidationExecute) {
            if (_checkLiquidationValid(payload)) {
                _handleLiquidationExecute(payload, srcEid);
            } else {
                _sendLiquidationFailure(payload, srcEid);
```
this will check if this liquidation call is valid, using _checkLiquidationValid function.And if it is valid then _handleLiquidationExecute function will execute, 
https://github.com/sherlock-audit/2025-05-lend-audit-contest/blob/713372a1ccd8090ead836ca6b1acf92e97de4679/Lend-V2/src/LayerZero/CrossChainRouter.sol#L312-L366
```solidity
    function _handleLiquidationExecute(LZPayload memory payload, uint32 srcEid) private {
        // Execute the seize of collateral
        uint256 protocolSeizeShare = mul_(payload.amount, Exp({mantissa: lendStorage.PROTOCOL_SEIZE_SHARE_MANTISSA()}));


        require(protocolSeizeShare < payload.amount, "Invalid protocol share");


        uint256 liquidatorShare = payload.amount - protocolSeizeShare;


        // Update protocol rewards
        lendStorage.updateProtocolReward(
            payload.destlToken, lendStorage.protocolReward(payload.destlToken) + protocolSeizeShare
        );


        // Distribute LEND rewards
        lendStorage.distributeSupplierLend(payload.destlToken, payload.sender); // borrower
        lendStorage.distributeSupplierLend(payload.destlToken, payload.liquidator); // liquidator


        // Update total investment for borrower
        lendStorage.updateTotalInvestment(
            payload.sender,
            payload.destlToken,
            lendStorage.totalInvestment(payload.sender, payload.destlToken) - payload.amount
        );


        // Update total investment for liquidator
        lendStorage.updateTotalInvestment(
            payload.liquidator,
            payload.destlToken,
            lendStorage.totalInvestment(payload.liquidator, payload.destlToken) + liquidatorShare
        );


        // Clear user supplied asset if total investment is 0
        if (lendStorage.totalInvestment(payload.sender, payload.destlToken) == 0) {
            lendStorage.removeUserSuppliedAsset(payload.sender, payload.destlToken);
        }


        emit LiquidateBorrow(
            payload.liquidator, // liquidator
            payload.srcToken, // borrowed token
            payload.sender, // borrower
            payload.destlToken // collateral token
        );


        _send(
            srcEid,
            payload.amount,
            0,
            0,
            payload.sender,
            payload.destlToken,
            payload.liquidator,
            payload.srcToken,
            ContractType.LiquidationSuccess
        );
    }
```

now let's see how _handleLiquidationSuccess function in chain B handles it,
https://github.com/sherlock-audit/2025-05-lend-audit-contest/blob/713372a1ccd8090ead836ca6b1acf92e97de4679/Lend-V2/src/LayerZero/CrossChainRouter.sol#L443-L457
```solidity
    function _handleLiquidationSuccess(LZPayload memory payload) private {
        // Find the borrow position on Chain B to get the correct srcEid
        address underlying = lendStorage.lTokenToUnderlying(payload.destlToken);


        // Find the specific collateral record
        (bool found, uint256 index) = lendStorage.findCrossChainCollateral(
            payload.sender,
            underlying,
            currentEid, // srcEid is current chain
            0, // We don't know destEid yet, but we can match on other fields
            payload.destlToken,
            payload.srcToken
        );


        require(found, "Borrow position not found");
```
here we are giving destEid =0  as input to  lendStorage.findCrossChainCollateral function,
https://github.com/sherlock-audit/2025-05-lend-audit-contest/blob/713372a1ccd8090ead836ca6b1acf92e97de4679/Lend-V2/src/LayerZero/LendStorage.sol#L683-L706
```solidity
    function findCrossChainCollateral(
        address user,
        address underlying,
        uint256 srcEid,
        uint256 destEid,
        address borrowedlToken,
        address srcToken
    ) public view returns (bool, uint256) {
        Borrow[] memory userCollaterals = crossChainCollaterals[user][underlying];


        for (uint256 i = 0; i < userCollaterals.length;) {
            if (
                userCollaterals[i].srcEid == srcEid && userCollaterals[i].destEid == destEid
                    && userCollaterals[i].borrowedlToken == borrowedlToken && userCollaterals[i].srcToken == srcToken
            ) {
                return (true, i);
            }
            unchecked {
                ++i;
            }
        }
        return (false, 0);
    }
}
```
but we should actually give currentEid  as input instead of 0.(because that is what stored in crossChainCollaterals[user][underlying] struct.
so this causes DOS of  _handleLiquidationSuccess function. because bool found = false.and below check will revert,
https://github.com/sherlock-audit/2025-05-lend-audit-contest/blob/713372a1ccd8090ead836ca6b1acf92e97de4679/Lend-V2/src/LayerZero/CrossChainRouter.sol#L457
```solidity
        require(found, "Borrow position not found");
```



### Root Cause

using 0 instead of currentEid in below lines of code ,
https://github.com/sherlock-audit/2025-05-lend-audit-contest/blob/713372a1ccd8090ead836ca6b1acf92e97de4679/Lend-V2/src/LayerZero/CrossChainRouter.sol#L452
```solidity
            0, // We don't know destEid yet, but we can match on other fields
```


### Internal Pre-conditions

none 

### External Pre-conditions

none 

### Attack Path

liquidator calls liquidate cross chain function 


### Impact

DOS of _handleLiquidationSuccess function.
due to this liquidator gets collateral tokens in chain A but he doesn't pay repay tokens in chain B.


### PoC

_No response_

### Mitigation

use currentEid instead of 0 in below lines of code ,
https://github.com/sherlock-audit/2025-05-lend-audit-contest/blob/713372a1ccd8090ead836ca6b1acf92e97de4679/Lend-V2/src/LayerZero/CrossChainRouter.sol#L452
```solidity
            0, // We don't know destEid yet, but we can match on other fields
```